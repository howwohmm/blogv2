{"pageProps":{"postData":{"slug":"doing-more-with-less-reducing-requests-to-the-stripe-api","title":"Doing more with less: Reducing requests to the Stripe API","summary":"The performance of an application can directly affect the customer experience. Using the expand feature along with caching techniques, developers can improve the performance of their application by reducing the number of API calls to Stripe.","authors":["Cecil Phillip"],"date":"2024-08-19","type":"Blog","topics":["Workbench"],"artConfig":{"ampX":1.8364052695935116,"ampY":0.7713401032732738,"aspectRatio":1.672809383550465,"axis":"x","lump":0.9759304509066895,"count":91.4999999999999,"freq":5.2168324480928945,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.31886574074074076,"mouseY":0.5007587253414264,"noise":0,"scale":1.293999999999998,"top":0,"twirl":0.1,"twist":51.86400000000122,"velocity":1,"shape":"ellipse"},"content":"\nIt is important for developers to optimize third-party API usage to reduce costs, improve performance, and enhance user experience. \n\nAn effective strategy to minimize the number of API calls to Stripe while still obtaining the necessary data involves caching and using the response [Expand](https://docs.stripe.com/expand) feature. This article discusses how using the expanding feature helps you retrieve related objects in a single request and tradeoffs of this approach. It also explores the use of caching for additional performance improvements, as well as show you how to inspect requests using tools available in Stripe Workbench.\n\n*The code samples in this post use the C\\# and Stripe .NET SDK, but the concepts are applicable for all supported languages.*\n\n### Expand resource requests\n\nAll core resources in the Stripe API, such as [Prices and Products](https://docs.stripe.com/products-prices/how-products-and-prices-work), have unique ID properties used to interact with specific instances. These IDs link related resources, like associating a price with its product or a customer with a subscription. When you retrieve an instance via an API request, you receive a baseline set of properties.\n\nFor example, when an e-commerce application must display detailed information about a product, it retrieves the product instance using its ID. This includes essential data like the product name, description, and images, which are necessary for providing customers with comprehensive product details on the website.\n\nUsing the `ProductService` class, pass the ID of a product in your Stripe catalog to the `GetAsync` method.\n\n```c#\nvar requestOptions = new RequestOptions { ApiKey = \"<secret-key>\"};\n\nvar productService = new ProductService();\nvar product = await productService.GetAsync(\"<product-id>\", requestOptions: requestOptions);\n\n```\n\nThe API response returns a JSON payload that all Stripe SDKs deserialize for you automatically. A typical payload resembles the example below.\n\n```json\n{\n \"id\": \"prod_NWjs8kKbJWmuuc\",\n \"object\": \"product\",\n \"active\": true,\n \"created\": 1678833149,\n \"default_price\": \"<price-id>\",\n \"description\": \"Black, Long Sleeve, Vintage Horizon Shirt\",\n \"images\": [],\n \"metadata\": {},\n \"name\": \"Vintage Horizon Shirt\",\n \"tax_code\": null,\n \"updated\": 1678833149,\n \"url\": null\n}\n\n```\n\n*This sample response shows a reduced set of returned properties.*\n\nDepending on what your goal is, this information may be sufficient. Notice the response does not contain any detailed pricing information. If you do need a price for this product, the only thing available for you to work with is the ID returned in the `default_price` property. You can use that property to issue a second request to retrieve the pricing information.\n\n```c#\nvar priceService = new PriceService();\nvar price = await priceService.GetAsync(product.DefaultPriceId, requestOptions: requestOptions);\n\n```\n\nThis is where it becomes important to understand what your applications are trying to accomplish. In some cases, it might be sufficient to not include that additional price data if it’s not needed. Returning less data results in faster response times and less of a payload to process, especially in high traffic scenarios. If your application needs the price along with the other product data, then it makes sense to retrieve them both at the same time if you can.\n\nYou can return related data, like the `default_price` property of a product, by using the expand parameter in API requests to Stripe. The [API reference](https://docs.stripe.com/api/products/object) docs for the Product object highlights which properties are expandable. \n\n![](/images/doing-more-with-less-reducing-requests-to-the-stripe-api/doing-more-with-less-reducing-requests-to-the-stripe-api-1.png)\n\nTo replace those two previous requests with a single one that uses the expand parameter, use the ProductGetOptions class from the [.NET SDK](https://github.com/stripe/stripe-dotnet) and provide it with a list of the expandable properties you need. For now it is just the default\\_price, but you can add additional properties to the list.\n\n```c#\nvar getOptions = new ProductGetOptions\n{\n    Expand = new List<string> { \"default_price\" }\n};\nvar productService = new ProductService();\nvar product = await productService.GetAsync(\"prod_PnyyMavtgHZNqV\", getOptions, requestOptions: requestOptions);\n```\n\nThat API response from the `ProductService` now contains more information. The `default_price` property is no longer a string but a nested object containing details about the associated price.\n\n```json\n{\n \"id\": \"prod_NWjs8kKbJWmuuc\",\n \"object\": \"product\",\n \"active\": true,\n \"created\": 1678833149,\n \"default_price\": {\n    \"id\": \"price_1OyN06BY4YhJumpKWZaLyKnJ\",\n    \"object\": \"price\",\n    \"active\": true,\n    \"billing_scheme\": \"per_unit\",\n    \"created\": 1711409542,\n    \"currency\": \"cad\",\n    \"product\": \"prod_PnyyMavtgHZNqV\",\n    \"recurring\": null,\n    \"tax_behavior\": \"unspecified\",\n    \"type\": \"one_time\",\n    \"unit_amount\": 4000,\n    \"unit_amount_decimal\": \"4000\"\n  },\n \"description\": \"Black, Long Sleeve, Vintage Horizon Shirt\",\n \"images\": [],\n \"metadata\": {},\n \"name\": \"Vintage Horizon Shirt\",\n \"tax_code\": null,\n \"updated\": 1678833149,\n \"url\": null\n}\n```\n\n*This sample response shows a reduced set of returned properties.*\n\nYou can use the expand feature in Stripe with Product, Price, and many other resources. This feature allows you to expand multiple properties on the same resource, including nested properties up to four levels deep. For example, if you need to get the currency options for a product's default price, use the dot notation in the expand parameter like this: `default_price.currency_options`. \n\n```json\n{\n  \"id\": \"prod_PnyyMavtgHZNqV\",\n  \"object\": \"product\",\n  \"created\": 1711409542,\n  \"default_price\": {\n    \"id\": \"price_1OyN06BY4YhJumpKWZaLyKnJ\",\n    \"object\": \"price\",    \n    \"billing_scheme\": \"per_unit\",\n    \"created\": 1711409542,\n    \"currency\": \"cad\",\n    \"currency_options\": {\n      \"cad\": {\n        \"custom_unit_amount\": null,\n        \"tax_behavior\": \"unspecified\",\n        \"unit_amount\": 4000,\n        \"unit_amount_decimal\": \"4000\"\n      }\n    },    \n    \"product\": \"prod_PnyyMavtgHZNqV\",\n    \"recurring\": null,\n    \"tax_behavior\": \"unspecified\", \n    \"type\": \"one_time\",\n    \"unit_amount\": 4000,\n    \"unit_amount_decimal\": \"4000\"\n  },\n  \"description\": \"Black, Long Sleeve, Vintage Horizon Shirt\", \n  \"livemode\": false,\n  \"metadata\": {},\n  \"name\": \"Vintage Horizon Shirt\",\n  \"tax_code\": \"txcd_30011000\"\n}\n```\n\n> This sample response shows a reduced set of returned properties.\n\nAfter issuing that request, you have the available currency options for the price of the specified product.\n\n### Working with resource lists\n\nThe expand feature is also available when working with lists of resources. Imagine your application contains a product listing page where it needs to show the name, image, description and price for each item. You must make an additional request to get the pricing information.\n\nThe `ProductService` class contains a [`ListAsync`](https://docs.stripe.com/api/products/list?lang=dotnet) method that you can use to return products that match the supplied list options.\n\n```c#\nvar listOptions = new ProductListOptions(){ Active = true, Limit = 10 };\n\nvar productService = new ProductService();\nvar priceService = new PriceService();\n\nawait foreach (var product in productService.ListAutoPagingAsync(listOptions, requestOptions))\n{\n   var price = await priceService.GetAsync(product.DefaultPriceId, requestOptions: requestOptions);\n   // add product data to pricing page\n}\n```\n\nIn the Stripe Dashboard, you can view the number of requests made to retrieve product information in the **Logs** tab in Workbench.\n\n![](/images/doing-more-with-less-reducing-requests-to-the-stripe-api/doing-more-with-less-reducing-requests-to-the-stripe-api-2.png)\n\nThe initial request for the list products is accompanied by six additional requests to get the price information.\n\nIf you inspect the payload for responses that return lists, you can see items inside of an array property named *data*. \n\n```json\n{\n \"object\": \"list\",\n \"url\": \"/v1/products\",\n \"has_more\": false,\n \"data\": [\n   {\n     \"id\": \"prod_NWjs8kKbJWmuuc\",\n     \"object\": \"product\",\n     \"active\": true,\n     \"created\": 1678833149,\n     \"default_price\": null,\n     \"description\": null,\n     \"images\": [],\n     \"livemode\": false,\n     \"metadata\": {},\n     \"name\": \"Gold Plan\",\n     \"updated\": 1678833149,\n     \"url\": null\n   }\n ]\n}\n```\n\nYou can use the expand feature when working with lists of resources similar to requesting individual ones. To request expandable properties to be included in list request, prefix each property name with `data`. This gives you a way to drill into the response and specify which property you need.\n\n```c#\nvar listOptions = new ProductListOptions()\n{\n   Active = true,\n   Limit = 10,\n   Expand = new List<string> { \"data.default_price\" }\n};\n\nvar productService = new ProductService();\n\nawait foreach (var product in productService.ListAutoPagingAsync(listOptions, requestOptions))\n{\n   var price = product.DefaultPrice;\n}\n\n```\n\nBack on the **Logs** tab in Workbench, refresh the logs and look at how many requests were made.\n\n![](/images/doing-more-with-less-reducing-requests-to-the-stripe-api/doing-more-with-less-reducing-requests-to-the-stripe-api-3.png)\n\nTo get all the information to display six products on a listing page, it only required one request to the Stripe API.\n\nIt is important to note that using the expand feature does come with some performance cost, especially when working with nested expansions. Deeper expansions increase the response payload size leading to longer response times and higher resource consumption. It is recommended that nested expansions are used sparingly. Using techniques like caching can help you find a balance getting the information you need without needing to make frequent requests to the API. \n\n### Adding caching\n\nIn high traffic scenarios, you can make your API read requests more efficient by adding a caching layer. This approach can significantly reduce the number of requests your application makes to Stripe, helping improve performance while also avoiding hitting rate limits. \n\nFor instance, product information tends to remain static, meaning subsequent calls often return identical data. By temporarily storing this data in an in-memory cache with sensible expiration defaults, your application can access the needed information more rapidly and with fewer network hops, leading to a smoother and more responsive user experience.\n\n```c#\n// Create a cache instance somewhere accessible throughout your application\nvar cache = new FusionCache(new FusionCacheOptions {\n   DefaultEntryOptions = new() {\n      Duration = TimeSpan.FromMinutes(5)\n   }\n});\n\n// User the cache to store product data from Stripe\nvar listOptions = new ProductListOptions()\n{\n   Active = true, Limit = 10,\n   Expand = new List<string> { \"data.default_price\" }\n};\n\nvar productService = new ProductService();\n\n// a for loop that iterates 10 times\nfor (int i = 0; i < 10; i++) {\n  var products =  await cache.GetOrSetAsync(\"products\", async _ => await productService.ListAsync(listOptions, requestOptions));\n}\n\n```\n\nThe previous code sample uses the in-memory cache capabilities of the FusionCache .NET library that allow you to configure various settings like the duration for cache entries. The [`GetOrSetAsync`](https://github.com/ZiggyCreatures/FusionCache/blob/main/docs/CoreMethods.md\\#getordefaultasync) method accepts a cache key and a factory method that knows how to get the data. Using this method has the added benefit of having FusionCache protect you against issues like [cache stampede](https://github.com/ZiggyCreatures/FusionCache/blob/main/docs/CacheStampede.md). \n\nWith these changes, your application can reduce API requests to Stripe while improving response times. With the original code sample, the number of requests to view a product listing page for one user would be 11: one request to get the list and 10 more to get the prices for each. For 1,000 concurrent users, that equates to 11,000 requests to Stripe. Using the caching example, it results in one request to Stripe with expansion to get the product and price data. All the other user requests would be served from the cache until it expires.\n\n### Conclusion\n\nUnderstanding your application's data requirements and operational boundaries is crucial for optimal performance. While occasional requests for small data sets might be manageable, scaling your solution and handling more complex data necessitates additional considerations. \n\nTools like Workbench within your Stripe merchant account offer valuable insights into the frequency and nature of your requests. With this knowledge, you can strategically implement request expansion and caching techniques to enhance efficiency and scalability.","authorBio":"","additionalResources":[{"title":"Subscribe to Stripe Developers on YouTube.","url":"https://www.youtube.com/stripedevelopers\""},{"title":"Follow us at @Stripedev on twitter for updates and answers to your developer questions.","url":"https://twitter.com/stripedev"},{"title":"Sign up for the Developer Digest.","url":"https://go.stripe.global/dev-digest"},{"title":"Join the Stripe Discord server to chat live with other developers.","url":"https://discord.com/invite/RuJnSBXrQn"},{"title":"Join Stripe Insiders to try the latest features and provide direct feedback to the teams that build them.","url":"https://insiders.stripe.dev"}],"relatedArticles":[{"slug":"observing-immediate-versus-delayed-payments-with-stripe-workbench","title":"Observing immediate versus delayed payments with Stripe Workbench","summary":"Immediate and delayed payments need to be handled differently within an integration. It’s important to understand what events to listen for and properties to inspect for relevant changes.","authors":["Cecil Phillip"],"date":"2024-08-23","type":"Blog","topics":["Workbench","Payment Methods"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"}},{"slug":"simple-error-handling-strategies-with-stripe-workbench","title":"Simple error handling strategies with Stripe Workbench","summary":"With Workbench, developers now have a bird’s-eye view of their integration which shows many potential issues in one place. This makes it easier to see the impact of each incident, see how often it’s happening, and receive actionable advice for resolving the issue.","authors":["Ben Smith"],"date":"2024-09-02","type":"Blog","topics":["Workbench","Error Handling"],"artConfig":{"ampX":0.24321052757950756,"ampY":0.21234603378855432,"aspectRatio":2.4639999999999973,"axis":"x","lump":1.7489999999999981,"count":116.19999999999999,"freq":0.8651107682703485,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"isBalls":false,"isMatrix":false,"left":0,"kaleids":8,"mouseX":0.9,"mouseY":0.8729838709677419,"noise":0,"scale":0.2736845318092905,"top":-58,"twirl":0.2,"twist":8.16200000000005,"velocity":2,"shape":"ellipse"}}]},"authors":[{"name":"Cecil Phillip","slug":"cecil-phillip","profile":"Cecil Phillip is a part of the Developer Relations team at Stripe. He is originally from St. John’s, Antigua and has over a decade of experience in building software for various industries. He’s a huge fan of .NET and loves learning about patterns for building distributed systems. Feel free to reach out to him on social media, and check out some of his videos on the Stripe Developer channel.","posts":[{"slug":"prepare-for-api-upgrades","authorBio":"","title":"Preparing for Stripe API Upgrades","summary":"New Stripe API versions come with new, and sometimes breaking, changes which should be evaluated before upgrading. Stripe Sandboxes and Workbench provide tooling to create isolated workspaces to test applications against these new changes.","authors":["Cecil Phillip"],"date":"2024-10-24","type":"Blog","topics":["Workbench"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"}},{"slug":"creating-reusable-dev-environments-with-sandboxes","authorBio":"","title":"Creating reusable developer environments with Stripe Sandboxes","summary":"When onboarding new team members, getting their development environments setup can be very time consuming. Preprovisioned environments with Stripe sandboxes and development containers can speed up their time to productivity.","authors":["Cecil Phillip"],"date":"2024-10-20","type":"Blog","topics":["Sandboxes"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"}},{"slug":"testing-subscriptions-with-stripe-test-clocks-and-workbench","authorBio":"","title":"Testing  subscriptions with Stripe Test Clocks and Workbench","summary":"Validating payment logic that gets triggered over a period of time is challenging and sometimes results in inelegant solutions.The combination of test clocks and workbench will improve the ability for developers to build and debug recurring payments.","authors":["Cecil Phillip"],"date":"2024-10-14","type":"Blog","topics":["Workbench","Payment Methods"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"}},{"slug":"observing-immediate-versus-delayed-payments-with-stripe-workbench","authorBio":"","title":"Observing immediate versus delayed payments with Stripe Workbench","summary":"Immediate and delayed payments need to be handled differently within an integration. It’s important to understand what events to listen for and properties to inspect for relevant changes.","authors":["Cecil Phillip"],"date":"2024-08-23","type":"Blog","topics":["Workbench","Payment Methods"],"artConfig":{"ampX":0.5330209860971548,"ampY":0.3805387571353413,"aspectRatio":0.41516675978899176,"axis":"x","lump":0,"count":34.20000000000001,"freq":2.19048980999072,"isDial":false,"isLineart":false,"isRing":false,"isSpiral":false,"left":0,"mouseX":0.7386574074074074,"mouseY":0.52,"noise":0,"scale":1.2797443644167636,"top":30,"twirl":0.2139585743169172,"twist":5.989515467478382,"velocity":1,"shape":"rect"}}]}],"estimatedReadingTime":"6 min read"},"__N_SSG":true}